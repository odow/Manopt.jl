<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stepsize · Manopt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Manopt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manopt.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../about.html">About</a></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../tutorials/MeanAndMedian.html">get Started: Optimize!</a></li><li><a class="tocitem" href="../tutorials/GeodesicRegression.html">Do Geodesic regression</a></li><li><a class="tocitem" href="../tutorials/HowToRecord.html">Record values</a></li><li><a class="tocitem" href="../tutorials/StochasticGradientDescent.html">do stochastic gradient descent</a></li><li><a class="tocitem" href="../tutorials/BezierCurves.html">work with Bézier curves</a></li><li><a class="tocitem" href="../tutorials/GradientOfSecondOrderDifference.html">see the gradient of <span>$d_2$</span></a></li><li><a class="tocitem" href="../tutorials/JacobiFields.html">use Jacobi Fields</a></li><li><a class="tocitem" href="../pluto/AutomaticDifferentiation.html">AD in Manopt</a></li></ul></li><li><span class="tocitem">Plans</span><ul><li><a class="tocitem" href="index.html">Specify a Solver</a></li><li><a class="tocitem" href="problem.html">Problem</a></li><li><a class="tocitem" href="options.html">Options</a></li><li class="is-active"><a class="tocitem" href="stepsize.html">Stepsize</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../solvers/index.html">Introduction</a></li><li><a class="tocitem" href="../solvers/alternating_gradient_descent.html">Alternating Gradient Descent</a></li><li><a class="tocitem" href="../solvers/ChambollePock.html">Chambolle-Pock</a></li><li><a class="tocitem" href="../solvers/conjugate_gradient_descent.html">Conjugate gradient descent</a></li><li><a class="tocitem" href="../solvers/cyclic_proximal_point.html">Cyclic Proximal Point</a></li><li><a class="tocitem" href="../solvers/DouglasRachford.html">Douglas–Rachford</a></li><li><a class="tocitem" href="../solvers/gradient_descent.html">Gradient Descent</a></li><li><a class="tocitem" href="../solvers/NelderMead.html">Nelder–Mead</a></li><li><a class="tocitem" href="../solvers/particle_swarm.html">Particle Swarm Optimization</a></li><li><a class="tocitem" href="../solvers/quasi_Newton.html">Quasi-Newton</a></li><li><a class="tocitem" href="../solvers/stochastic_gradient_descent.html">Stochastic Gradient Descent</a></li><li><a class="tocitem" href="../solvers/subgradient.html">Subgradient method</a></li><li><a class="tocitem" href="../solvers/truncated_conjugate_gradient_descent.html">Steihaug-Toint TCG Method</a></li><li><a class="tocitem" href="../solvers/trust_regions.html">Trust-Regions Solver</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../functions/index.html">Introduction</a></li><li><a class="tocitem" href="../functions/bezier.html">Bézier curves</a></li><li><a class="tocitem" href="../functions/costs.html">Cost functions</a></li><li><a class="tocitem" href="../functions/differentials.html">Differentials</a></li><li><a class="tocitem" href="../functions/adjointdifferentials.html">Adjoint Differentials</a></li><li><a class="tocitem" href="../functions/gradients.html">Gradients</a></li><li><a class="tocitem" href="../functions/Jacobi_fields.html">Jacobi Fields</a></li><li><a class="tocitem" href="../functions/proximal_maps.html">Proximal Maps</a></li><li><a class="tocitem" href="../functions/manifold.html">Specific Manifold Functions</a></li></ul></li><li><span class="tocitem">Helpers</span><ul><li><a class="tocitem" href="../helpers/checks.html">Checks</a></li><li><a class="tocitem" href="../helpers/data.html">Data</a></li><li><a class="tocitem" href="../helpers/errorMeasures.html">Error Measures</a></li><li><a class="tocitem" href="../helpers/exports.html">Exports</a></li></ul></li><li><a class="tocitem" href="../contributing.html">Contributing to Manopt.jl</a></li><li><a class="tocitem" href="../notation.html">Notation</a></li><li><a class="tocitem" href="../list.html">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Plans</a></li><li class="is-active"><a href="stepsize.html">Stepsize</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="stepsize.html">Stepsize</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/Manopt.jl/blob/master/docs/src/plans/stepsize.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Stepsize-1"><a class="docs-heading-anchor" href="#Stepsize-1">Stepsize and Linesearch</a><a class="docs-heading-anchor-permalink" href="#Stepsize-1" title="Permalink"></a></h1><p>Most iterative algorithms determine a direction along which the algorithm will proceed and determine a step size to find the next iterate. How advanced the step size computation can be implemented depends (among others) on the properties the corresponding problem provides.</p><p>Within <code>Manopt.jl</code> the step size determination is implemented as a <code>Functor</code> based on</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.Stepsize" href="#Manopt.Stepsize"><code>Manopt.Stepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Stepsize</code></pre><p>An abstract type for the functors representing step sizes, i.e. they are callable structures. The naming scheme is <code>TypeOfStepSize</code>, e.g. <code>ConstantStepsize</code>.</p><p>Every Stepsize has to provide a constructor and its function has to have the interface <code>(p,o,i)</code> where a <a href="problem.html#Manopt.Problem"><code>Problem</code></a> as well as <a href="options.html#Manopt.Options"><code>Options</code></a> and the current number of iterations are the arguments and returns a number, namely the stepsize to use.</p><p><strong>See also</strong></p><p><a href="stepsize.html#Manopt.Linesearch"><code>Linesearch</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/options.jl#L71-L84">source</a></section></article><p>Usually a constructor should take the manifold <code>M</code> as its first argument, for consistency, to allow general step size functors to be set up based on default values that might depend on the manifold currently under consideration.</p><p>Currently thw following step sizes are available</p><article class="docstring"><header><a class="docstring-binding" id="Manopt.ArmijoLinesearch" href="#Manopt.ArmijoLinesearch"><code>Manopt.ArmijoLinesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArmijoLinesearch &lt;: Linesearch</code></pre><p>A functor representing Armijo line search including the last runs state, i.e. a last step size.</p><p><strong>Fields</strong></p><ul><li><code>initialStepsize</code> – (<code>1.0</code>) and initial step size</li><li><code>retraction_method</code> – (<code>ExponentialRetraction()</code>) the rectraction to use, defaults to the exponential map</li><li><code>contractionFactor</code> – (<code>0.95</code>) exponent for line search reduction</li><li><code>sufficientDecrease</code> – (<code>0.1</code>) gain within Armijo&#39;s rule</li><li><code>last_stepsize</code> – (<code>initialstepsize</code>) the last step size we start the search with</li><li><code>linesearch_stopsize</code> - (<code>0.0</code>) a safeguard when to stop the line search   before the step is numerically zero. This should be combined with <a href="../solvers/index.html#Manopt.StopWhenStepSizeLess"><code>StopWhenStepSizeLess</code></a></li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">ArmijoLineSearch()</code></pre><p>with the Fields above in their order as optional arguments (deprecated).</p><pre><code class="language-none">ArmijoLineSearch(M)</code></pre><p>with the Fields above as keyword arguments and the retraction is set to the default retraciton on <code>M</code>.</p><p>The constructors return the functor to perform Armijo line search, where two inter faces are available:</p><ul><li>based on a tuple <code>(p,o,i)</code> of a <a href="problem.html#Manopt.GradientProblem"><code>GradientProblem</code></a> <code>p</code>, <a href="options.html#Manopt.Options"><code>Options</code></a> <code>o</code> and a current iterate <code>i</code>.</li><li>with <code>(M, x, F, gradFx[,η=-gradFx]) -&gt; s</code> where <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/interface.html#Manifold">Manifold</a> <code>M</code>, a current point <code>x</code> a function <code>F</code>, that maps from the manifold to the reals, its gradient (a tangent vector) <code>gradFx</code><span>$=\operatorname{grad}F(x)$</span> at  <code>x</code> and an optional search direction tangent vector <code>η=-gradFx</code> are the arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L112-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.ConstantStepsize" href="#Manopt.ConstantStepsize"><code>Manopt.ConstantStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantStepsize &lt;: Stepsize</code></pre><p>A functor that always returns a fixed step size.</p><p><strong>Fields</strong></p><ul><li><code>length</code> – constant value for the step size.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none">ConstantStepsize(s)</code></pre><p>initialize the stepsize to a constant <code>s</code> (deprecated)</p><pre><code class="language-none">ConstantStepsize(M::AbstractManifold=DefaultManifold(2); stepsize=injectivity_radius(M)/2)</code></pre><p>initialize the stepsize to a constant <code>stepsize</code>, which by default is half the injectivity radius, unless the radius is infinity, then the default step size is <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.DecreasingStepsize" href="#Manopt.DecreasingStepsize"><code>Manopt.DecreasingStepsize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DecreasingStepsize()</code></pre><p>A functor that represents several decreasing step sizes</p><p><strong>Fields</strong></p><ul><li><code>length</code> – (<code>1</code>) the initial step size <span>$l$</span>.</li><li><code>factor</code> – (<code>1</code>) a value <span>$f$</span> to multiply the initial step size with every iteration</li><li><code>subtrahend</code> – (<code>0</code>) a value <span>$a$</span> that is subtracted every iteration</li><li><code>exponent</code> – (<code>1</code>) a value <span>$e$</span> the current iteration numbers <span>$e$</span>th exponential is taken of</li><li><code>shift</code> – (<code>0</code>) shift the denominator iterator <span>$i$</span> by <span>$s$</span>`.</li></ul><p>In total the complete formulae reads for the <span>$i$</span>th iterate as</p><div>\[s_i = \frac{(l - i a)f^i}{(i+s)^e}\]</div><p>and hence the default simplifies to just <span>$s_i = \frac{l}{i}$</span></p><p><strong>Constructor</strong></p><pre><code class="language-none">DecreasingStepsize(l=1,f=1,a=0,e=1,s=0)</code></pre><p>Alternatively one can also use the following keyword.</p><pre><code class="language-none">DecreasingStepsize(
    M::AbstractManifold=DefaultManifold(3);
    length=injectivity_radius(M)/2, multiplier=1.0, subtrahend=0.0, exponent=1.0, shift=0)</code></pre><p>initialiszes all fields above, where none of them is mandatory and the length is set to half and to <span>$1$</span> if the injectivity radius is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L37-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.Linesearch" href="#Manopt.Linesearch"><code>Manopt.Linesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Linesearch &lt;: Stepsize</code></pre><p>An abstract functor to represent line search type step size deteminations, see <a href="stepsize.html#Manopt.Stepsize"><code>Stepsize</code></a> for details. One example is the <a href="stepsize.html#Manopt.ArmijoLinesearch"><code>ArmijoLinesearch</code></a> functor.</p><p>Compared to simple step sizes, the linesearch functors provide an interface of the form <code>(p,o,i,η) -&gt; s</code> with an additional (but optional) fourth parameter to provide a search direction; this should default to something reasonable, e.g. the negative gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L98-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.NonmonotoneLinesearch" href="#Manopt.NonmonotoneLinesearch"><code>Manopt.NonmonotoneLinesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonmonotoneLinesearch &lt;: Linesearch</code></pre><p>A functor representing a nonmonotone line search using the Barzilai-Borwein step size<sup class="footnote-reference"><a id="citeref-Iannazzo2018" href="#footnote-Iannazzo2018">[Iannazzo2018]</a></sup>. Together with a gradient descent algorithm this line search represents the Riemannian Barzilai-Borwein with nonmonotone line-search (RBBNMLS) algorithm. We shifted the order of the algorithm steps from the paper by Iannazzo and Porcelli so that in each iteration we first find</p><div>\[y_{k} = \operatorname{grad}F(x_{k}) - \operatorname{T}_{x_{k-1} → x_k}(\operatorname{grad}F(x_{k-1}))\]</div><p>and</p><div>\[s_{k} = - α_{k-1} * \operatorname{T}_{x_{k-1} → x_k}(\operatorname{grad}F(x_{k-1})),\]</div><p>where <span>$α_{k-1}$</span> is the step size computed in the last iteration and <span>$\operatorname{T}$</span> is a vector transport. We then find the Barzilai–Borwein step size</p><div>\[α_k^{\text{BB}} = \begin{cases}
\min(α_{\text{max}}, \max(α_{\text{min}}, τ_{k})),  &amp; \text{if } ⟨s_{k}, y_{k}⟩_{x_k} &gt; 0,\\
α_{\text{max}}, &amp; \text{else,}
\end{cases}\]</div><p>where</p><div>\[τ_{k} = \frac{⟨s_{k}, s_{k}⟩_{x_k}}{⟨s_{k}, y_{k}⟩_{x_k}},\]</div><p>if the direct strategy is chosen,</p><div>\[τ_{k} = \frac{⟨s_{k}, y_{k}⟩_{x_k}}{⟨y_{k}, y_{k}⟩_{x_k}},\]</div><p>in case of the inverse strategy and an alternation between the two in case of the alternating strategy. Then we find the smallest <span>$h = 0, 1, 2, …$</span> such that</p><div>\[F(\operatorname{retr}_{x_k}(- σ^h α_k^{\text{BB}} \operatorname{grad}F(x_k)))
\leq
\max_{1 ≤ j ≤ \min(k+1,m)} F(x_{k+1-j}) - γ σ^h α_k^{\text{BB}} ⟨\operatorname{grad}F(x_k), \operatorname{grad}F(x_k)⟩_{x_k},\]</div><p>where <span>$σ$</span> is a step length reduction factor <span>$∈ (0,1)$</span>, <span>$m$</span> is the number of iterations after which the function value has to be lower than the current one and <span>$γ$</span> is the sufficient decrease parameter <span>$∈(0,1)$</span>. We can then find the new stepsize by</p><div>\[α_k = σ^h α_k^{\text{BB}}.\]</div><p><strong>Fields</strong></p><ul><li><code>initial_stepsize</code> – (<code>1.0</code>) the step size we start the search with</li><li><code>linesearch_stopsize</code> - (<code>0.0</code>) a safeguard when to stop the line search   before the step is numerically zero. This should be combined with <a href="../solvers/index.html#Manopt.StopWhenStepSizeLess"><code>StopWhenStepSizeLess</code></a></li><li><code>memory_size</code> – (<code>10</code>) number of iterations after which the cost value needs to be lower than the current one</li><li><code>min_stepsize</code> – (<code>1e-3</code>) lower bound for the Barzilai-Borwein step size greater than zero</li><li><code>max_stepsize</code> – (<code>1e3</code>) upper bound for the Barzilai-Borwein step size greater than min_stepsize</li><li><code>retraction_method</code> – (<code>ExponentialRetraction()</code>) the rectraction to use</li><li><code>strategy</code> – (<code>direct</code>) defines if the new step size is computed using the direct, indirect or alternating strategy</li><li><code>storage</code> – (<code>x</code>, <code>gradient</code>) a <a href="options.html#Manopt.StoreOptionsAction"><code>StoreOptionsAction</code></a> to store <code>old_x</code> and <code>old_gradient</code>, the x-value and corresponding gradient of the previous iteration</li><li><code>stepsize_reduction</code> – (<code>0.5</code>) step size reduction factor contained in the interval (0,1)</li><li><code>sufficient_decrease</code> – (<code>1e-4</code>) sufficient decrease parameter contained in the interval (0,1)</li><li><code>vector_transport_method</code> – (<code>ParallelTransport()</code>) the vector transport method to use</li></ul><p><strong>Constructor</strong></p><pre><code class="language-none">NonmonotoneLinesearch()</code></pre><p>with the Fields above in their order as optional arguments (deprecated).</p><pre><code class="language-none">NonmonotoneLinesearch(M)</code></pre><p>with the Fields above in their order as keyword arguments and where the retraction and vector transport are set to the default ones on <code>M</code>, repsectively.</p><p>The constructors return the functor to perform nonmonotone line search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L258-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.WolfePowellBinaryLinesearch" href="#Manopt.WolfePowellBinaryLinesearch"><code>Manopt.WolfePowellBinaryLinesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WolfePowellBinaryLinesearch &lt;: Linesearch</code></pre><p>A <a href="stepsize.html#Manopt.Linesearch"><code>Linesearch</code></a> method that determines a step size <code>t</code> fulfilling the Wolfe conditions</p><p>based on a binary chop. Let <span>$η$</span> be a search direction and <span>$c1,c_2&gt;0$</span> be two constants. Then with</p><div>\[A(t) = f(x_+) ≤ c1 t ⟨\operatorname{grad}f(x), η⟩_{x}
\quad\text{and}\quad
W(t) = ⟨\operatorname{grad}f(x_+), \text{V}_{x_+\gets x}η⟩_{x_+} ≥ c_2 ⟨η, \operatorname{grad}f(x)⟩_x,\]</div><p>where <span>$x_+ = \operatorname{retr}_x(tη)$</span> is the current trial point, and <span>$\text{V}$</span> is a vector transport, we perform the following Algorithm similar to Algorithm 7 from <sup class="footnote-reference"><a id="citeref-Huang2014" href="#footnote-Huang2014">[Huang2014]</a></sup></p><ol><li>set <span>$α=0$</span>, <span>$β=∞$</span> and <span>$t=1$</span>.</li><li>While either <span>$A(t)$</span> does not hold or <span>$W(t)$</span> does not hold do steps 3-5.</li><li>If <span>$A(t)$</span> fails, set <span>$β=t$</span>.</li><li>If <span>$A(t)$</span> holds but <span>$W(t)$</span> fails, set <span>$α=t$</span>.</li><li>If <span>$β&lt;∞$</span> set <span>$t=\frac{α+β}{2}$</span>, otherwise set <span>$t=2α$</span>.</li></ol><p><strong>Constructors</strong></p><p>There exist two constructors, where, when prodivind the manifold <code>M</code> as a first (optional) parameter, its default retraction and vector transport are the default. In this case the retraction and the vector transport are also keyword arguments for ease of use. The other constructor is kept for backward compatibility. Note that the <code>linesearch_stopsize</code> to stop for too small stepsizes is only available in the new signature including <code>M</code>, for the first it is set to the old default of <code>1e-9</code>.</p><pre><code class="language-none">WolfePowellBinaryLinesearch(
    retr::AbstractRetractionMethod=ExponentialRetraction(),
    vtr::AbstractVectorTransportMethod=ParallelTransport(),
    c1::Float64=10^(-4),
    c2::Float64=0.999
)

WolfePowellLinesearch(
    M,
    c1::Float64=10^(-4),
    c2::Float64=0.999;
    retraction_method = default_retraction_method(M),
    vector_transport_method = default_vector_transport(M),
    linesearch_stopsize = 0.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L656-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.WolfePowellLinesearch" href="#Manopt.WolfePowellLinesearch"><code>Manopt.WolfePowellLinesearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WolfePowellLinesearch &lt;: Linesearch</code></pre><p>Do a backtracking linesearch to find a step size <span>$α$</span> that fulfils the Wolfe conditions along a search direction <span>$η$</span> starting from <span>$x$</span>, i.e.</p><div>\[f\bigl( \operatorname{retr}_x(αη) \bigr) ≤ f(x_k) + c_1 α_k ⟨\operatorname{grad}f(x), η⟩_x
\quad\text{and}\quad
\frac{\mathrm{d}}{\mathrm{d}t} f\bigr(\operatorname{retr}_x(tη)\bigr)
\Big\vert_{t=α}
≥ c_2 \frac{\mathrm{d}}{\mathrm{d}t} f\bigl(\operatorname{retr}_x(tη)\bigr)\Big\vert_{t=0}.\]</div><p><strong>Constructors</strong></p><p>There exist two constructors, where, when prodivind the manifold <code>M</code> as a first (optional) parameter, its default retraction and vector transport are the default. In this case the retraction and the vector transport are also keyword arguments for ease of use. The other constructor is kept for backward compatibility. Note that the <code>linesearch_stopsize</code> to stop for too small stepsizes is only available in the new signature including <code>M</code>. For the old (deprecated) signature the <code>linesearch_stopsize</code> is set to the old hard-coded default of  <code>1e-12</code></p><pre><code class="language-none">WolfePowellLinesearch(
    retr::AbstractRetractionMethod=ExponentialRetraction(),
    vtr::AbstractVectorTransportMethod=ParallelTransport(),
    c1::Float64=10^(-4),
    c2::Float64=0.999
)

WolfePowellLinesearch(
    M,
    c1::Float64=10^(-4),
    c2::Float64=0.999;
    retraction_method = default_retraction_method(M),
    vector_transport_method = default_vector_transport(M),
    linesearch_stopsize = 0.0
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L526-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.get_stepsize-Tuple{Problem, Options, Vararg{Any, N} where N}" href="#Manopt.get_stepsize-Tuple{Problem, Options, Vararg{Any, N} where N}"><code>Manopt.get_stepsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_stepsize(p::Problem, o::Options, vars...)</code></pre><p>return the stepsize stored within <a href="options.html#Manopt.Options"><code>Options</code></a> <code>o</code> when solving <a href="problem.html#Manopt.Problem"><code>Problem</code></a> <code>p</code>. This method also works for decorated options and the <a href="stepsize.html#Manopt.Stepsize"><code>Stepsize</code></a> function within the options, by default stored in <code>o.stepsize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L777-L783">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T, Any}} where {TF, T}" href="#Manopt.linesearch_backtrack-Union{Tuple{T}, Tuple{TF}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T}, Tuple{AbstractManifold, TF, Any, T, Any, Any, Any, AbstractRetractionMethod, T, Any}} where {TF, T}"><code>Manopt.linesearch_backtrack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linesearch_backtrack(M, F, x, gradFx, s, decrease, contract, retr, η = -gradFx, f0 = F(x); stop_step=0.)</code></pre><p>perform a linesearch for</p><ul><li>a manifold <code>M</code></li><li>a cost function <code>F</code>,</li><li>an iterate <code>x</code></li><li>the gradient <span>$\operatorname{grad}F(x)$</span></li><li>an initial stepsize <code>s</code> usually called <span>$γ$</span></li><li>a sufficient <code>decrease</code></li><li>a <code>contract</code>ion factor <span>$σ$</span></li><li>a <code>retr</code>action, which defaults to the <code>ExponentialRetraction()</code></li><li>a search direction <span>$η = -\operatorname{grad}F(x)$</span></li><li>an offset, <span>$f_0 = F(x)$</span></li><li>a keyword <code>stop_step</code> as a minimal step size when to stop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/Manopt.jl/blob/53ca41779b0e66cd65a12605461527beaac70610/src/plans/stepsize.jl#L205-L220">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Iannazzo2018"><a class="tag is-link" href="#citeref-Iannazzo2018">Iannazzo2018</a><blockquote><p>B. Iannazzo, M. Porcelli, <strong>The Riemannian Barzilai–Borwein Method with Nonmonotone Line Search and the Matrix Geometric Mean Computation</strong>, In: IMA Journal of Numerical Analysis. Volume 38, Issue 1, January 2018, Pages 495–517, doi <a href="https://doi.org/10.1093/imanum/drx015">10.1093/imanum/drx015</a></p></blockquote></li><li class="footnote" id="footnote-Huang2014"><a class="tag is-link" href="#citeref-Huang2014">Huang2014</a><blockquote><p>Huang, W.: <em>Optimization algorithms on Riemannian manifolds with applications</em>, Dissertation, Flordia State University, 2014. <a href="https://www.math.fsu.edu/~whuang2/pdf/Huang_W_Dissertation_2013.pdf">pdf</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="options.html">« Options</a><a class="docs-footer-nextpage" href="../solvers/index.html">Introduction »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 24 April 2022 08:41">Sunday 24 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
